var documenterSearchIndex = {"docs":
[{"location":"guided_examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"This section a work in progress.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"An explanation of the theory can be found here.","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The tutorial for FastMultipole is a work in progress. While we work on creating a tutorial, see the example file scripts/simple_gravitational.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = FastMultipole","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/#FastMultipole.DerivativesSwitch","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch\n\nSwitch indicating whether the scalar potential, vector potential, velocity, and/or velocity gradient should be computed for a target system. Information is stored as type parameters, allowing the compiler to compile away if statements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.DerivativesSwitch-NTuple{4, Any}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient)\n\nConstructs a tuple of DerivativesSwitch objects.\n\nArguments\n\nscalar_potential::Vector{Bool}: a vector of ::Bool indicating whether the scalar potential should be computed for each target system\nvector_potential::Vector{Bool}: a vector of ::Bool indicating whether the vector potential should be computed for each target system\nvelocity::Vector{Bool}: a vector of ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Vector{Bool}: a vector of ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-NTuple{4, Bool}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient)\n\nConstructs a single DerivativesSwitch object.\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for the target system\nvector_potential::Bool: a ::Bool indicating whether the vector potential should be computed for the target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for the target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for the target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool, Bool, Tuple}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient, target_systems)\n\nConstructs a ::Tuple of indentical DerivativesSwitch objects of the same length as target_systems (if it is a ::Tuple), or a single DerivativesSwitch (if target_system is not a ::Tuple)\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for each target system\nvector_potential::Bool: a ::Bool indicating whether the vector potential should be computed for each target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.MultiTree","page":"Reference","title":"FastMultipole.MultiTree","text":"bodies[indexlist] is the same sort operation as performed by the tree sortedbodies[inverseindexlist] undoes the sort operation performed by the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem\n\nConvenience system for defining locations at which the potential, velocity, or velocity gradient may be desired.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Array{StaticArraysCore.SVector{3, TF}, 1}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nA convenience system constructor for calculating the influence of source systems at locations not already described by a system object. It behaves like a system whose elements induce a null potential field.\n\nArguments\n\npositions::Vector{SVector{3,Float64}}: a vector of position vectors of each probe\n\nOptional Arguments\n\nscalar_potential::Bool: whether or not to compute the scalar potential at each probe location\nvector_potential::Bool: whether or not to compute the vector potential at each probe location\nvelocity::Bool: whether or not to compute the velocity at each probe location\nvelocity_gradient::Bool: whether or not to compute the velocity gradient at each probe location\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Matrix{TF}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nDispatch of ProbeSystem accepting a matrix of horizontally concatenated column vectors describing the position of each probe. Optional arguments are identical.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.SortWrapper-Tuple{Any}","page":"Reference","title":"FastMultipole.SortWrapper","text":"SortWrapper(system)\n\nConvenience wrapper for systems whose elements cannot be sorted in-place (e.g. structured grids). The resulting object is treated like any other system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.Tree","page":"Reference","title":"FastMultipole.Tree","text":"abstract type Tree{TF,P} end\n\nSupertype of all octree structures with TF the floating point type and P the expansion order.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.EmptyTree-Tuple{Any}","page":"Reference","title":"FastMultipole.EmptyTree","text":"EmptyTree(system)\n\nReturns an empty tree. Used if system is empty.\n\nArguments\n\nsystem: the system from which a tree is to be created\n\nReturns\n\ntree: if typeof(system)<:Tuple, a ::MultiTree is returned; otherwise, a ::SingleTree is returned\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.L2B_velocity-Union{Tuple{VPS}, Tuple{PS}, Tuple{TF2}, Tuple{TF1}, Tuple{TF1, Any, Any, Any, Any, Any, Any, Any, TF2, Any, Any, Any, Any, Any, Any, Any, Any, Any, DerivativesSwitch{PS, VPS}}} where {TF1, TF2, PS, VPS}","page":"Reference","title":"FastMultipole.L2B_velocity","text":"Does not include the rotation matrix R yet. Eq 28 in S&L\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.L2B_velocity_gradient-Union{Tuple{VPS}, Tuple{PS}, Tuple{TF}, Tuple{TF, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DerivativesSwitch{PS, VPS}}} where {TF, PS, VPS}","page":"Reference","title":"FastMultipole.L2B_velocity_gradient","text":"Eq 35-37 S&L\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.add_line!-Tuple{ProbeSystem, Vararg{Any, 4}}","page":"Reference","title":"FastMultipole.add_line!","text":"add_line!(probes::ProbeSystem, x1, x2, n_probes, i_last)\n\nAdds n_probes probes in a line between x1 and x2. Specifically, they are added at the midpoint of equally partiti    oned segments of the line.\n\nArguments\n\nprobes::ProbeSystem: the probe system whose .position field is to be updated\nx1::Vector{Float64}: the first point defining the line along which probes are to be added\nx2::Vector{Float64}: the second point defining the line along which probes are to be added\nn_probes::Int: number of probes to be added\ni_last::Int: index of the last probe in probes\n\nOutput\n\ni_last::Int: updated index of the last probe in probes\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.d2rdx2-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.d2rdx2","text":"drk/dxidx_j\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(target_system, source_system; derivatives_switches)\n\nApplies all interactions of source_system acting on target_system without multipole acceleration.\n\nArguments\n\ntarget_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Tuple}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(systems; derivatives_switches)\n\nApplies all interactions of systems acting on itself without multipole acceleration.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.drdx-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.drdx","text":"drj/dxi\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_systems, source_systems; kwargs...)\n\nApply all interactions of source_systems acting on target_systems using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size_source::Int: maximum number of bodies from source_systems allowed in a leaf-level branch\nleaf_size_target::Int: maximum number of bodies from target_systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the target_systems\nsource_shink_recenter::Bool: indicates whether or not to resize branches for the source_systems octree after it is created to increase computational efficiency\ntarget_shink_recenter::Bool: indicates whether or not to resize branches for the target_systems octree after it is created to increase computational efficiency\nsave_tree::Bool: indicates whether or not to save a VTK file for visualizing the octree\nsave_name::String: name and path of the octree visualization if save_tree == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(systems; kwargs...)\n\nApply all interactions of systems acting on itself using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size::Int: maximum number of bodies from systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\nshink_recenter::Bool: indicates whether or not to resize branches for the octree after it is created to increase computational efficiency\nsave_tree::Bool: indicates whether or not to save a VTK file for visualizing the octree\nsave_name::String: name and path of the octree visualization if save_tree == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any, Tree, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any, Tree, Vararg{Any, 4}}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems, m2l_list, direct_list, derivatives_switches; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Vararg{Any, 4}}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-NTuple{9, Any}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"multiple source systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Tuple{Any, Any, Any, Tuple, Any, Tuple, Any, Any}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source body, multiple target systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{GS}, Tuple{VS}, Tuple{VPS}, Tuple{PS}, Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, UnitRange, DerivativesSwitch{PS, VPS, VS, GS}, Any, Any}} where {TF, PS, VPS, VS, GS}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source body, single target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, Any, Any, Any, Any, UnitRange, Int64}} where TF","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, Any, Any, Any, UnitRange, Int64}} where TF","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source system (without specifying icolprev)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.reset!-Tuple{ProbeSystem}","page":"Reference","title":"FastMultipole.reset!","text":"reset!(probes)\n\nZeroes all values (e.g. scalar/vector potential, velocity, and/or velocity gradient) of all probes.\n\nArguments\n\nprobes::ProbeSystem: a ::ProbeSystem object\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.resort!-Tuple{Tuple, FastMultipole.MultiTree}","page":"Reference","title":"FastMultipole.resort!","text":"Performs the same sort operation as the tree. (Undoes unsort! operation.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.unsort!-Tuple{Tuple, FastMultipole.MultiTree}","page":"Reference","title":"FastMultipole.unsort!","text":"Undoes the sort operation performed by the tree.\n\n\n\n\n\n","category":"method"},{"location":"#FastMultipole","page":"Introduction","title":"FastMultipole","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FastMultipole is a highly performant, CPU parallelized fast multipole code suitable for accelerating large N-body problems in scalar and or vector potentials with a wide range of applications, including astronomy, electro-magnetism, and fluid-dynamics. Typical use cases include boundary element problems, such as 3-dimensional panel methods. The code is compatible with ForwardDiff and ReverseDiff algorithmic differentiation for gradient-based design optimization. Its elegant interface makes it extremely easy to incorporate into existing Julia code with minimal modification. Convenience functions are provided for generating the expansions of source and vortex points and constant source and doublet panels, with more support planned for the future. It currently supports only the Laplace kernel, though this may change soon.","category":"page"}]
}
