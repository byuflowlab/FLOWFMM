var documenterSearchIndex = {"docs":
[{"location":"advanced_usage/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Though the typical user won't need to alter these parameters, various situations may require modifications to the evaluation process of the FMM.","category":"page"},{"location":"advanced_usage/#Unsort-Bodies","page":"Advanced Usage","title":"Unsort Bodies","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"As part of the evaluation, the fmm! call will sort bodies contained in the systems in order to optimize performance, thus during the fmm evaluation, the body indices are different from initial indices given by the user. At the conclusion of the fmm! call, these bodies are then put back in their original order for the convenience of the user. This feature can be toggled off so that the bodies are left in their sorted order after the FMM evaluation.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"import FastMultipole as fmm\nusing Random\ngravitational_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\ntarget_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system,\n    unsort_source_bodies=true, unsort_target_bodies=true) # standard run (defaults)\nfmm.fmm!(target_system, source_system,\n    unsort_source_bodies=false, unsort_target_bodies=false) # sorted bodies (not original indices)","category":"page"},{"location":"advanced_usage/#Reusing-the-Octree","page":"Advanced Usage","title":"Reusing the Octree","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"Users are able to define the tree to be used in the FMM by passing in a previously created tree into the fmm! call. For convenience, the upward_pass, horizontal_pass, and downward_pass can be toggled off seperately. These are important to toggle when generating octrees to be reused. Additionally, unsort_target_bodies and unsort_source_bodies should be set to false when generating the reusable trees.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"upward_pass creates the multipole expansions for each branch\nhorizontal_pass evaluates the expansions in the appropriate locations\ndownward_pass applies parent expansions to children branches","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\ntarget_tree, source_tree = fmm.fmm!(target_system, source_system;\n    upward_pass=true, horizontal_pass=false, downward_pass=false,\n    unsort_source_bodies=false, unsort_target_bodies=false) # generating trees to be reused\n\nfmm.fmm!(target_tree, target_system, source_tree, source_system;\n    upward_pass=false, horizontal_pass=true, downward_pass=true) # reusing trees","category":"page"},{"location":"advanced_usage/#Partial-Evaluation","page":"Advanced Usage","title":"Partial Evaluation","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"The nearfield, farfield, and self_induced parameters allow users to bypass certain portions of the FMM.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"nearfield if false, FastMultipole omits all direct interactions\nfarfield if false, FastMultipole omits all multipole interactions\nself_induced if false, FastMultipole omits the interaction of each leaf branch on itself","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"system = generate_gravitational(123, 100)\nfmm.fmm!(system,\n    nearfield=true, farfield=true, self_induced=true) # standard run (defaults)\nfmm.fmm!(system,\n    nearfield=false, farfield=true, self_induced=true) # nearfield not evaluated","category":"page"},{"location":"advanced_usage/#Resize-and-Recenter-Branches","page":"Advanced Usage","title":"Resize and Recenter Branches","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"The initial creation of the octree will create uniformly sized and spaced branches in each level. These branches are not centered or optimally sized with relation to the bodies they contain. As a default, the fmm! call resizes and recenters these branches to utilize the smallest possible radius that contains all the bodies in each branch[2]. This feature can be toggled with the source_shrink_recenter and target_shrink_recenter parameters.","category":"page"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system,\n    source_shrink_recenter=true, target_shrink_recenter=true) # standard run (defaults)\nfmm.fmm!(target_system, source_system,\n    source_shrink_recenter=false, target_shrink_recenter=false) # no branch recentering","category":"page"},{"location":"advanced_usage/#References","page":"Advanced Usage","title":"References","text":"","category":"section"},{"location":"advanced_usage/","page":"Advanced Usage","title":"Advanced Usage","text":"N. A. Gumerov, S. Kaneko and R. Duraiswami. Recursive computation of the multipole expansions of layer potential integrals over simplices for efficient fast multipole accelerated boundary elements. Journal of Computational Physics 486, 112118 (2023).\n\n\n\nS. DENG, C. JIANG, Y. WANG and H. WANG. Acceleration of unsteady vortex lattice method via dipole panel fast multipole method. Chinese Journal of Aeronautics 34, 265–278 (2021).\n\n\n\nL. Greengard and V. Rokhlin. A fast algorithm for particle simulations. Journal of computational physics 73, 325–348 (1987).\n\n\n\n","category":"page"},{"location":"guided_examples/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole is designed to incorporate easily into your existing Julia code with minimal effort. We'll walk through the process of adding FastMultipole to an existing code in the following guided examples.","category":"page"},{"location":"guided_examples/#Gravitational-Example","page":"Guided Examples","title":"Gravitational Example","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In order to use FastMultipole, certain interface functions must be defined. In this example, we will walk through the process of incorporating FMM into the gravitational point mass model used in Quick Start. This code can also be found under test/gravitational.jl. Note that an additional (minimalistic) vortex particle example is included in test/vortex.jl.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"To better understand how the FastMultipole interface functions, let's take a look at the data structures we'll use to define our point masses:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"using FastMultipole\nusing FastMultipole.StaticArrays\n\nconst i_POTENTIAL = 1:4             # index of the gravitational potential\nconst i_VELOCITY = 5:7              # index of the velocity\nconst i_VELOCITY_GRADIENT = 8:16    # index of the velocity gradient\n\n# a single point mass\nstruct Body{TF}\n    position::SVector{3,TF}\n    radius::TF\n    strength::SVector{4,TF}\nend\n\n# container for a system of `Body`'s\nstruct Gravitational{TF}\n    bodies::Vector{Body{TF}}\n    potential::Matrix{TF}\nend\n\n# constructor\nfunction Gravitational(bodies::Matrix)\n    nbodies = size(bodies)[2]\n    bodies2 = [Body(SVector{3}(bodies[1:3,i]),bodies[4,i],SVector{4}(bodies[5:8,i])) for i in 1:nbodies]\n    potential = zeros(52,nbodies)\n    return Gravitational(bodies2,potential)\nend","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that while the particular choice of data structures is completely arbitrary, FastMultipole does not create any new storage containers for values of interest such as potential, velocity, velocity gradient. If these are desired, they must exist in the user-defined system, and will be updated in-place by FastMultipole.","category":"page"},{"location":"guided_examples/#Overloading-the-B2M!-Function","page":"Guided Examples","title":"Overloading the B2M! Function","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The function B2M! is used to generate multipole expansions for our particular system. This is done be overloading B2M! for the data structure representing our model. Convenience functions exist within FastMultipole to make this complicated function into a one-liner:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMultipole.B2M!(system::Gravitational, args...) =\n    FastMultipole.B2M!_sourcepoint(system, args...)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that we are overloading B2M! to operate on our ::Gravitational system. Other convenience functions exist in FastMultipole for:","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"vortex point\nsource panel\ndipole panel","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"with additional elements currently in development. We use the fast recursive method of generating exact coefficients for panels as developed by [1].","category":"page"},{"location":"guided_examples/#Overloading-Getters","page":"Guided Examples","title":"Overloading Getters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The Gravitational struct needs the following getters to be overloaded to support the indexing format used by FastMultipole. This approach allows for great flexibility without harming performance.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import Base: getindex\n\nBase.getindex(g::Gravitational, i, ::FastMultipole.Position) = g.bodies[i].position\nBase.getindex(g::Gravitational, i, ::FastMultipole.Radius) = g.bodies[i].radius\nBase.getindex(g::Gravitational, i, ::FastMultipole.VectorPotential) = view(g.potential,2:4,i)\nBase.getindex(g::Gravitational, i, ::FastMultipole.ScalarPotential) = g.potential[1,i]\nBase.getindex(g::Gravitational, i, ::FastMultipole.Velocity) = view(g.potential,i_VELOCITY,i)\nBase.getindex(g::Gravitational, i, ::FastMultipole.VelocityGradient) = reshape(view(g.potential,i_VELOCITY_GRADIENT,i),3,3)\nBase.getindex(g::Gravitational, i, ::FastMultipole.Strength) = g.bodies[i].strength[1]\nBase.getindex(g::Gravitational, i, ::FastMultipole.Body) = g.bodies[i], view(g.potential,:,i)","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"It is worth noting that there are ways of defining these functions that would harm performance, e.g. by allocating an array each time the velocity is requested. It is up to the user to define these functions with the efficiency they desire.","category":"page"},{"location":"guided_examples/#Overloading-Setters","page":"Guided Examples","title":"Overloading Setters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Gravitational also needs the following setters to be overloaded as well. These are used to update the potential and other quantities in-place. The same performance considerations that applied to getters apply here.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import Base: setindex!\n\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.Body)\n    body, potential = val\n    g.bodies[i] = body\n    g.potential[:,i] .= potential\n    return nothing\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.ScalarPotential)\n    g.potential[i_POTENTIAL[1],i] = val\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.VectorPotential)\n    g.potential[i_POTENTIAL[2:4],i] .= val\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.Velocity)\n    g.potential[i_VELOCITY,i] .= val\nend\nfunction Base.setindex!(g::Gravitational, val, i, ::FastMultipole.VelocityGradient)\n    reshape(g.potential[i_VELOCITY_GRADIENT,i],3,3) .= val\nend","category":"page"},{"location":"guided_examples/#Additional-Requirements","page":"Guided Examples","title":"Additional Requirements","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"In addition to the getters and setters listed above, each system struct must be overloaded with three additional methods. In gravitational.jl, these are they are overloaded as follows.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"# determine the number of bodies contained by the system\nFastMultipole.get_n_bodies(g::Gravitational) = length(g.bodies)\n\n# determine the float-type used by the system\nBase.eltype(::Gravitational{TF}) where TF = TF\n\n# return all data structures required to define a single body\nFastMultipole.buffer_element(g::Gravitational) = (deepcopy(g.bodies[1]),zeros(eltype(g),52))","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Note that the last of these functions, buffer_element, can return a tuple of values in case multiple data structures are required to define a single body.","category":"page"},{"location":"guided_examples/#Non-required-Functionality","page":"Guided Examples","title":"Non-required Functionality","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"Though not required to run Fast Multipole, the direct! and save_vtk functions are useful for debugging and visualization. Here are some examples of how this could be implemented.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"function FastMultipole.direct!(target_system, target_index, derivatives_switch, source_system::Gravitational, source_index)\n    # nbad = 0\n    for i_source in source_index\n        source_x, source_y, source_z = source_system[i_source,FastMultipole.POSITION]\n        source_strength = source_system.bodies[i_source].strength[1]\n        for j_target in target_index\n            target_x, target_y, target_z = target_system[j_target,FastMultipole.POSITION]\n            dx = target_x - source_x\n            dy = target_y - source_y\n            dz = target_z - source_z\n            r = sqrt(dx*dx + dy*dy + dz*dz)\n            # te = @elapsed begin\n            if r > 0\n                dV = source_strength / r\n                target_system[j_target,FastMultipole.SCALAR_POTENTIAL] += dV\n            end\n        # end\n        # if te > 0.00001; nbad += 1; end\n        end\n    end\n    # println(\"nbad = $nbad\")\nend\n\nfunction save_vtk(filename, element::Gravitational, nt=0; compress=false, extra_fields=nothing)\n    _, n = size(element.bodies)\n    WriteVTK.vtk_grid(filename*\"_point_masses.\"*string(nt)*\".vts\", reshape(view(element.bodies,1:3,:),3,n,1,1); compress) do vtk\n        vtk[\"strength\"] = reshape(view(element.bodies,4,:), 1, n, 1, 1)\n        vtk[\"velocity\"] = reshape(element.velocity, 3, n, 1, 1)\n        vtk[\"scalar potential\"] = reshape(view(element.potential,1,:), n, 1, 1)\n        vtk[\"vector potential\"] = reshape(view(element.potential,2:4,:), 3, n, 1, 1)\n        if !isnothing(extra_fields)\n            for i in 1:length(extra_fields)\n                vtk[extra_fields[i][1]] = extra_fields[i][2]\n            end\n        end\n    end\nend\n","category":"page"},{"location":"guided_examples/#FMM-Tuning-Parameters","page":"Guided Examples","title":"FMM Tuning Parameters","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"We can improve the accuracy of the FMM by altering the follwing input parameters: multipole_threshold, leaf_size, and expansion_order. Though not linear, expansion_order is positively correlated with accuracy while multipole_threshold and leaf_size are negatively correlated.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"multipole_threshold (between 0 and 1) the radius of the source over the minimum distance at which multipole expansion are used\nleaf_size (greater than 1) the maximum number of bodies included in each leaf level branch\nexpansion_order the number of terms included in each multipole expansion minus one","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"import FastMultipole as fmm\nusing Random\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\nfunction measure_error(;multipole_threshold=0.4, leaf_size=50, expansion_order=5)\n    fmm_system = generate_gravitational(123,1000)\n    direct_system = deepcopy(fmm_system)\n\n    fmm.fmm!(fmm_system; multipole_threshold, leaf_size, expansion_order)\n    fmm.direct!(direct_system)\n\n    percent_error = abs.((fmm_system.potential[1,:] .- direct_system.potential[1,:]) ./ direct_system.potential[1,:])\n    return maximum(percent_error)\nend\n\n# default parameters\nprintln(measure_error(multipole_threshold=0.4, leaf_size=50, expansion_order=5))\n\n# expansion_order increased to 10\nprintln(measure_error(multipole_threshold=0.4, leaf_size=50, expansion_order=10))","category":"page"},{"location":"guided_examples/#Evaluate-Source-on-Target","page":"Guided Examples","title":"Evaluate Source on Target","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"FastMutipole allows for the evaluation of source systems on target systems while leaving the source systems unaltered.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"target_system = generate_gravitational(123, 100)\nsource_system = generate_gravitational(321, 100)\n\nfmm.fmm!(target_system, source_system)","category":"page"},{"location":"guided_examples/#Evaluate-Multiple-Sources-on-Multiple-Targets","page":"Guided Examples","title":"Evaluate Multiple Sources on Multiple Targets","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"The FMM also supports the evaluation of multiple source systems on multiple target systems. The user is also able to evaluate a single source on multiple targets or multiple sources on a single target with any combination of supported system types.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"vortex_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"vortex.jl\"))\ninclude(vortex_path)\n\nfunction generate_vortex(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = VortexParticles(bodies)\n    return system\nend\n\ntarget_one = generate_gravitational(123, 100)\ntarget_two = generate_vortex(124, 100)\n\nsource_one = generate_gravitational(125, 100)\nsource_two = generate_vortex(126, 100)\n\nfmm.fmm!((target_one, target_two), (source_one, source_two))","category":"page"},{"location":"guided_examples/#Non-Potential-Flow-Applications","page":"Guided Examples","title":"Non-Potential Flow Applications","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"As a default, target systems will be evaluated and returned with scalar_potential, vector_potential, velocity, and velocity_gradient fields populated. In some situations, only some of these values may be required. By inputting a boolean vector of the same length as target systems, the user is able to speed up the calculation by not storing unecessary values.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"overlineV = -nabla phi + nabla times overlinepsi","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":" phi overlinepsi overlineV nabla overlineV\nfmm! Keyword Arguments scalar_potential vector_potential velocity velocity_gradient\nFluid Dynamics Scalar Potential Stream Function Fluid Velocity Velocity Gradient\nElectrostatics Electric Potential - Electric Field Field Gradient Tensor\nMagnetostatics - Magnetic Vector Potential Magnetic Field Field Gradient Tensor\nGravity Gravitational Potential - Gravitational Acceleration Acceleration Gradient Tensor","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"target_one = generate_gravitational(123, 100)\ntarget_two = generate_vortex(124, 100)\n\nsource_one = generate_gravitational(125, 100)\n\nfmm.fmm!((target_one, target_two), source_one, scalar_potential=[true, false],\n    vector_potential=[false, true], velocity=[true, true], velocity_gradient=[false, false])","category":"page"},{"location":"guided_examples/#Saving-Generated-Trees","page":"Guided Examples","title":"Saving Generated Trees","text":"","category":"section"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"A given fmm! call will typically return a single tree (if performed on the entire system) or two seperate source/target trees (if called on a source and a target). The function call can also be modified to save these trees.","category":"page"},{"location":"guided_examples/","page":"Guided Examples","title":"Guided Examples","text":"\ntarget_filepath = \"target_tree\"\nsource_filepath = \"source_tree\"\n\ntarget_tree, source_tree = fmm.fmm!((target_one, target_two), source_one;\n    save_tree_target=true, save_name_target=target_filepath,\n    save_tree_source=true, save_name_source=source_filepath)","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"In a nutshell, FastMultipole operates by forming series expansions of a kernel function, and translating and combining those expansions to obtain optimal compression. You can get a sense for how this works in the following figure.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"multipole_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here, we see how each body's influence can be expressed as a series expansion. These series expansions can be translated and combined such that an entire cluster of bodies is represented by a single series expansion. This is what is known as a multipole expansion. Multipole expansions only converge outside of a finite radius of convergence, as illustrated by the red dotted line. Multipole expansions can only be used for interactions that are farther apart than this circl. The accuracy of the expansion gets better and better the farther away we go, so we can control the accuracy by imposing a cutoff radius (dotted blue line), and only use multipole expansions for interactions that are farther away than the blue circle. Multipole expansions are very helpful for reducing the cost of the N-body problem; in fact, we can reduce the scaling of the N-body problem to O(NlogN) by only considering multipole expansions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Local expansions are very similar to multipole expansions, but they converge inside of a finite radius rather than outside. These provide the additional required compression to achieve fully O(N) scaling. In the next figure, we see how local expansions can reduce the number of times an expansion need be evaluated.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"<img src=\"local_expansions.png\" width=\"660px\"/>","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"More details of the fast multipole method (FMM) can be found in the original work by Greengard and Rokhlin.[3]","category":"page"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The following tutorial shows how to use FastMultipole to compute the gravitational potential induced by a collection of point masses. It uses data structures located in test/gravitational.jl.","category":"page"},{"location":"quickstart/#Create-a-System","page":"Quick Start","title":"Create a System","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"First, let's create a system of 1000 randomly spaced point masses:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using Random\nimport FastMultipole as fmm\ngravitational_path = normpath(joinpath(splitdir(pathof(fmm))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_factor=1.0)\n    Random.seed!(seed)\n    bodies = rand(8,n_bodies)\n    bodies[1:3,:] = rand(3,n_bodies) # body positions\n\n    bodies[4,:] ./= (n_bodies^(1/3)*2) # body radii\n    bodies[4,:] .*= radius_factor\n\n    bodies[5,:] .*= strength_factor # body strengths\n\n    system = Gravitational(bodies)\n    return system\nend\n\nsystem = generate_gravitational(123, 1000)","category":"page"},{"location":"quickstart/#Evaluate-The-Potential-at-Each-Body","page":"Quick Start","title":"Evaluate The Potential at Each Body","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The fmm! function evaluates the gravitational potential induced by system in-place. We can control the tradeoff between performance and accuracy by tuning a handful of parameters for our particular system, but we'll stick with the defaults for this example:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"fmm.fmm!(system)","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"The resulting potential can then be accessed as a field of system.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"@show system.potential[1,:]","category":"page"},{"location":"quickstart/#Accuracy-of-FMM-Call","page":"Quick Start","title":"Accuracy of FMM Call","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"By using the direct! function, we can check the accuracy of the fmm! call by evaluating the ''N''-body problem naively, without fast multipole acceleration.","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"direct_system = deepcopy(system)\ndirect_system.potential .= 0\n\nfmm.direct!(direct_system)\n\npercent_error = abs.((system.potential[1,:] .- direct_system.potential[1,:]) ./ direct_system.potential[1,:])\n\n@show maximum(percent_error)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = FastMultipole","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FastMultipole]\nOrder = [:constant, :type, :function]\n# Pages = [\"fmm.jl\"]","category":"page"},{"location":"reference/#FastMultipole.DerivativesSwitch","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch\n\nSwitch indicating whether the scalar potential, vector potential, velocity, and/or velocity gradient should be computed for a target system. Information is stored as type parameters, allowing the compiler to compile away if statements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.DerivativesSwitch-NTuple{4, Any}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient)\n\nConstructs a tuple of DerivativesSwitch objects.\n\nArguments\n\nscalar_potential::Vector{Bool}: a vector of ::Bool indicating whether the scalar potential should be computed for each target system\nvector_potential::Vector{Bool}: a vector of ::Bool indicating whether the vector potential should be computed for each target system\nvelocity::Vector{Bool}: a vector of ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Vector{Bool}: a vector of ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-NTuple{4, Bool}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient)\n\nConstructs a single DerivativesSwitch object.\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for the target system\nvector_potential::Bool: a ::Bool indicating whether the vector potential should be computed for the target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for the target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for the target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.DerivativesSwitch-Tuple{Bool, Bool, Bool, Bool, Tuple}","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch(scalar_potential, vector_potential, velocity, velocity_gradient, target_systems)\n\nConstructs a ::Tuple of indentical DerivativesSwitch objects of the same length as target_systems (if it is a ::Tuple), or a single DerivativesSwitch (if target_system is not a ::Tuple)\n\nArguments\n\nscalar_potential::Bool: a ::Bool indicating whether the scalar potential should be computed for each target system\nvector_potential::Bool: a ::Bool indicating whether the vector potential should be computed for each target system\nvelocity::Bool: a ::Bool indicating whether the velocity should be computed for each target system\nvelocity_gradient::Bool: a ::Bool indicating whether the velocity gradient should be computed for each target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.MultiTree","page":"Reference","title":"FastMultipole.MultiTree","text":"bodies[indexlist] is the same sort operation as performed by the tree sortedbodies[inverseindexlist] undoes the sort operation performed by the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem\n\nConvenience system for defining locations at which the potential, velocity, or velocity gradient may be desired.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Array{StaticArraysCore.SVector{3, TF}, 1}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nA convenience system constructor for calculating the influence of source systems at locations not already described by a system object. It behaves like a system whose elements induce a null potential field.\n\nArguments\n\npositions::Vector{SVector{3,Float64}}: a vector of position vectors of each probe\n\nOptional Arguments\n\nscalar_potential::Bool: whether or not to compute the scalar potential at each probe location\nvector_potential::Bool: whether or not to compute the vector potential at each probe location\nvelocity::Bool: whether or not to compute the velocity at each probe location\nvelocity_gradient::Bool: whether or not to compute the velocity gradient at each probe location\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.ProbeSystem-Union{Tuple{Matrix{TF}}, Tuple{TF}} where TF","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem(positions; kwargs...)\n\nDispatch of ProbeSystem accepting a matrix of horizontally concatenated column vectors describing the position of each probe. Optional arguments are identical.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.SortWrapper-Tuple{Any}","page":"Reference","title":"FastMultipole.SortWrapper","text":"SortWrapper(system)\n\nConvenience wrapper for systems whose elements cannot be sorted in-place (e.g. structured grids). The resulting object is treated like any other system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.Tree","page":"Reference","title":"FastMultipole.Tree","text":"abstract type Tree{TF,P} end\n\nSupertype of all octree structures with TF the floating point type and P the expansion order.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.EmptyTree-Tuple{Any}","page":"Reference","title":"FastMultipole.EmptyTree","text":"EmptyTree(system)\n\nReturns an empty tree. Used if system is empty.\n\nArguments\n\nsystem: the system from which a tree is to be created\n\nReturns\n\ntree: if typeof(system)<:Tuple, a ::MultiTree is returned; otherwise, a ::SingleTree is returned\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.L2B_velocity-Union{Tuple{VPS}, Tuple{PS}, Tuple{TF2}, Tuple{TF1}, Tuple{TF1, Any, Any, Any, Any, Any, Any, Any, TF2, Any, Any, Any, Any, Any, Any, Any, Any, Any, DerivativesSwitch{PS, VPS}}} where {TF1, TF2, PS, VPS}","page":"Reference","title":"FastMultipole.L2B_velocity","text":"Does not include the rotation matrix R yet. Eq 28 in S&L\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.L2B_velocity_gradient-Union{Tuple{VPS}, Tuple{PS}, Tuple{TF}, Tuple{TF, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, DerivativesSwitch{PS, VPS}}} where {TF, PS, VPS}","page":"Reference","title":"FastMultipole.L2B_velocity_gradient","text":"Eq 35-37 S&L\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.add_line!-Tuple{ProbeSystem, Vararg{Any, 4}}","page":"Reference","title":"FastMultipole.add_line!","text":"add_line!(probes::ProbeSystem, x1, x2, n_probes, i_last)\n\nAdds n_probes probes in a line between x1 and x2. Specifically, they are added at the midpoint of equally partiti    oned segments of the line.\n\nArguments\n\nprobes::ProbeSystem: the probe system whose .position field is to be updated\nx1::Vector{Float64}: the first point defining the line along which probes are to be added\nx2::Vector{Float64}: the second point defining the line along which probes are to be added\nn_probes::Int: number of probes to be added\ni_last::Int: index of the last probe in probes\n\nOutput\n\ni_last::Int: updated index of the last probe in probes\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.d2rdx2-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.d2rdx2","text":"drk/dxidx_j\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(target_system, source_system; derivatives_switches)\n\nApplies all interactions of source_system acting on target_system without multipole acceleration.\n\nArguments\n\ntarget_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_system: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.direct!-Tuple{Tuple}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(systems; derivatives_switches)\n\nApplies all interactions of systems acting on itself without multipole acceleration.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.drdx-Tuple{Any, Any, Any}","page":"Reference","title":"FastMultipole.drdx","text":"drj/dxi\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Any, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_systems, source_systems; kwargs...)\n\nApply all interactions of source_systems acting on target_systems using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size_source::Int: maximum number of bodies from source_systems allowed in a leaf-level branch\nleaf_size_target::Int: maximum number of bodies from target_systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for the target_systems\nsource_shink_recenter::Bool: indicates whether or not to resize branches for the source_systems octree after it is created to increase computational efficiency\ntarget_shink_recenter::Bool: indicates whether or not to resize branches for the target_systems octree after it is created to increase computational efficiency\nsave_tree_source::Bool: indicates whether or not to save a VTK file for visualizing the source octree\nsave_tree_target::Bool: indicates whether or not to save a VTK file for visualizing the target octree\nsave_name_source::String: name and path of the source octree visualization if save_tree == true\nsave_name_target::String: name and path of the target octree visualization if save_tree == true\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(systems; kwargs...)\n\nApply all interactions of systems acting on itself using the fast multipole method. Assumes compatibility functions have been overloaded for both source and target systems.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nexpansion_order::Int: the expansion order to be used\nleaf_size::Int: maximum number of bodies from systems allowed in a leaf-level branch\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\nshink_recenter::Bool: indicates whether or not to resize branches for the octree after it is created to increase computational efficiency\nsave_tree::Bool: indicates whether or not to save a VTK file for visualizing the octree\nsave_name::String: name and path of the octree visualization if save_tree == true\ngpu::Bool: indicates whether or not GPU is to be used for direct interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any, Tree, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nreset_source_tree::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(source_systems) indicating whether or not to reset the expansions of each source tree\nreset_target_tree::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(source_systems) indicating whether or not to reset the expansions of each target tree\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\ngpu::Bool: indicates whether or not GPU is to be used for direct interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any, Tree, Vararg{Any, 5}}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_tree, target_systems, source_tree, source_systems, m2l_list, direct_list, derivatives_switches; kwargs...)\n\nDispatches fmm! using existing ::Tree objects.\n\nArguments\n\ntarget_tree::Tree: a <:Tree object (see Tree)\ntarget_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nsource_tree::Tree: a <:Tree object (see Tree)\nsource_systems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (comuted without multipoles) interactions should be included\nfarfield::Bool: indicates whether far-field (comuted with multipoles) interactions should be included\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself\nunsort_source_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for source_systems\nunsort_target_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for target_systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Any}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n\nOptional Arguments\n\nmultipole_threshold::Float64: number between 0 and 1 (often denoted theta in [0,1]) controls the accuracy by determining the non-dimensional distance after which multipoles are used; 0 means an infinite distance (no error, high cost), and 1 means barely convergent (high error, low cost)\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a scalar potential from source_systems\nvector_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a vector potential from source_systems\nvelocity::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity from source_systems\nvelocity_gradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(systems) indicating whether each system should receive a velocity gradient from source_systems\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nnearfield::Bool: indicates whether near-field (computed without multipoles) interactions should be included in the direct_list\nfarfield::Bool: indicates whether far-field (computed with multipoles) interactions should be included in the m2l_list\nself_induced::Bool: indicates whether to include the interactions of each leaf-level branch on itself in the direct_list\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\ngpu::Bool: indicates whether or not GPU is to be used for direct interactions\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.fmm!-Tuple{Tree, Vararg{Any, 5}}","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(tree, systems; kwargs...)\n\nDispatches fmm! using an existing ::Tree.\n\nArguments\n\ntree::Tree: a <:Tree object (see Tree)\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\nm2l_list::Vector{SVector{2,Int32}}: list of branch index pairs [i_target, i_source] for which multipole expansions of the source branch are to be transformed to local expansions at the target branch\ndirect_list::Union{Vector{SVector{2,Int32}}, InteractionList}: list of branch index pairs [i_target, i_source] for which interactions are to be evaluted without multipole expansion (i.e., directly); if typeof(direct_list) <: InteractionList, then prepared influence matrices are used rather than computing direct influences on the fly\nderivatives_switches::Union{DerivativesSwitch, Tuple{<:DerivativesSwitch,...}}: switch determining which of scalar potential, vector potential, velocity, and/or velocity gradient are to be computed for each target system\n\nOptional Arguments\n\nupward_pass::Bool: whether or not to form the multipole expansions from source bodies and translate them upward in the source tree\nhorizontal_pass::Bool: whether or not to transform multipole expansions from the source tree into local expansions in the target tree\ndownward_pass::Bool: whether or not to translate local expansions down to the leaf level of the target tree and evaluate them\nunsort_bodies::Bool: indicates whether or not to undo the sort operation used to generate the octree for systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-NTuple{9, Any}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"multiple source systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Tuple{Any, Any, Any, Tuple, Any, Tuple, Any, Any}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source body, multiple target systems\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{GS}, Tuple{VS}, Tuple{VPS}, Tuple{PS}, Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, UnitRange, DerivativesSwitch{PS, VPS, VS, GS}, Any, Any}} where {TF, PS, VPS, VS, GS}","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source body, single target system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, Any, Any, Any, Any, UnitRange, Int64}} where TF","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source system\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.populate_influence_matrix!-Union{Tuple{TF}, Tuple{Matrix{TF}, Any, Any, Any, Any, Any, Any, UnitRange, Int64}} where TF","page":"Reference","title":"FastMultipole.populate_influence_matrix!","text":"single source system (without specifying icolprev)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.reset!-Tuple{ProbeSystem}","page":"Reference","title":"FastMultipole.reset!","text":"reset!(probes)\n\nZeroes all values (e.g. scalar/vector potential, velocity, and/or velocity gradient) of all probes.\n\nArguments\n\nprobes::ProbeSystem: a ::ProbeSystem object\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.resort!-Tuple{Tuple, FastMultipole.MultiTree}","page":"Reference","title":"FastMultipole.resort!","text":"Performs the same sort operation as the tree. (Undoes unsort! operation.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.unsort!-Tuple{Tuple, FastMultipole.MultiTree}","page":"Reference","title":"FastMultipole.unsort!","text":"Undoes the sort operation performed by the tree.\n\n\n\n\n\n","category":"method"},{"location":"#FastMultipole","page":"Introduction","title":"FastMultipole","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FastMultipole is a highly performant, CPU parallelized, pure julia fast multipole code suitable for accelerating large N-body problems in scalar and or vector potentials with a wide range of applications, including astronomy, electro-magnetism, and fluid-dynamics. Fast, analytic, recursive expressions are used to compute first and second derivatives of the potential (i.e., velocity and velocity gradient for fluid dynamics). The code is compatible with ForwardDiff and ReverseDiff algorithmic differentiation for gradient-based design optimization. Its elegant interface makes it extremely easy to incorporate into existing Julia code with minimal modification. Convenience functions are provided for generating the expansions of source and vortex points and constant source and doublet panels, with more support planned for the future. It currently only provides expansions that obey Laplace's equation, though this may change soon.","category":"page"}]
}
